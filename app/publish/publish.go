package publish

import (
	"errors"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	"path"

	"github.com/lbryio/lbrytv/app/proxy"
	"github.com/lbryio/lbrytv/app/users"
	"github.com/lbryio/lbrytv/config"
	"github.com/lbryio/lbrytv/internal/monitor"

	"github.com/gorilla/mux"
)

// FileFieldName refers to the POST field containing file upload
const FileFieldName = "file"

// JSONRPCFieldName is a name of the POST field containing JSONRPC request accompanying the uploaded file
const JSONRPCFieldName = "json_payload"

const fileNameParam = "file_path"

var logger = monitor.NewModuleLogger("publish")

// Publisher is responsible for sending data to lbrynet
// and should take file path, account ID and client query as a slice of bytes.
type Publisher interface {
	Publish(string, string, []byte) []byte
}

// LbrynetPublisher is an implementation of SDK publisher.
type LbrynetPublisher struct {
	*proxy.Service
}

// UploadHandler glues HTTP uploads to the Publisher.
type UploadHandler struct {
	Publisher  Publisher
	UploadPath string
}

type UploadOpts struct {
	Path         string
	Publisher    Publisher
	ProxyService *proxy.Service
}

// NewUploadHandler returns a HTTP upload handler object.
func NewUploadHandler(opts UploadOpts) (*UploadHandler, error) {
	var (
		publisher  Publisher
		uploadPath string
	)
	if opts.ProxyService != nil {
		publisher = &LbrynetPublisher{Service: opts.ProxyService}
	} else if opts.Publisher != nil {
		publisher = opts.Publisher
	} else {
		return nil, errors.New("need either a ProxyService or a Publisher instance")
	}

	if opts.Path == "" {
		uploadPath = config.GetPublishSourceDir()
	} else {
		uploadPath = opts.Path
	}
	return &UploadHandler{
		Publisher:  publisher,
		UploadPath: uploadPath,
	}, nil
}

// Publish takes a file path, account ID and client JSON-RPC query,
// patches the query and sends it to the SDK for processing.
// Resulting response is then returned back as a slice of bytes.
func (p *LbrynetPublisher) Publish(filePath, walletID string, rawQuery []byte) []byte {
	c := p.Service.NewCaller()
	c.SetWalletID(walletID)
	c.SetPreprocessor(func(q *proxy.Query) {
		params := q.ParamsAsMap()
		params[fileNameParam] = filePath
		q.Request.Params = params
	})
	r := c.Call(rawQuery)
	return r
}

// Handle is where HTTP upload is handled and passed on to Publisher.
// It should be wrapped with users.Authenticator.Wrap before it can be used
// in a mux.Router.
func (h UploadHandler) Handle(w http.ResponseWriter, r *users.AuthenticatedRequest) {
	w.WriteHeader(http.StatusOK)
	if !r.IsAuthenticated() {
		var authErr Error
		if r.AuthFailed() {
			authErr = NewAuthError(r.AuthError)
		} else {
			authErr = ErrUnauthorized
		}
		w.Write(authErr.AsBytes())
		return
	}

	r.Body = http.MaxBytesReader(w, r.Body, config.GetMaxUploadSizeMB()*1024*1024)

	f, err := h.saveFile(r)
	if err != nil {
		logger.Log().Error(err)
		monitor.CaptureException(err)
		w.Write(NewInternalError(err).AsBytes())
		return
	}

	response := h.Publisher.Publish(f.Name(), r.WalletID, []byte(r.FormValue(JSONRPCFieldName)))

	if err := os.Remove(f.Name()); err != nil {
		monitor.CaptureException(err, map[string]string{"file_path": f.Name()})
	}

	w.Write(response)
}

// CanHandle checks if http.Request contains POSTed data in an accepted format.
// Supposed to be used in gorilla mux router MatcherFunc.
func (h UploadHandler) CanHandle(r *http.Request, _ *mux.RouteMatch) bool {
	_, _, err := r.FormFile(FileFieldName)
	payload := r.FormValue(JSONRPCFieldName)
	return err != http.ErrMissingFile && payload != ""
}

// createFile opens an empty file for writing inside the account's designated folder.
// The final file path looks like `/upload_path/{wallet_id}/{random}_filename.ext`,
// where `wallet_id` is local SDK wallet ID and `random` is a random string generated by ioutil.
func (h UploadHandler) createFile(walletID string, origFilename string) (*os.File, error) {
	path, err := h.preparePath(walletID)
	if err != nil {
		return nil, err
	}
	return ioutil.TempFile(path, fmt.Sprintf("*_%v", origFilename))
}

func (h UploadHandler) preparePath(walletID string) (string, error) {
	path := path.Join(h.UploadPath, walletID)
	err := os.MkdirAll(path, os.ModePerm)
	return path, err
}

func (h UploadHandler) saveFile(r *users.AuthenticatedRequest) (*os.File, error) {
	log := logger.LogF(monitor.F{"account_id": r.WalletID})

	file, header, err := r.FormFile(FileFieldName)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	f, err := h.createFile(r.WalletID, header.Filename)
	if err != nil {
		return nil, err
	}
	log.Infof("processing uploaded file %v", header.Filename)

	numWritten, err := io.Copy(f, file)
	if err != nil {
		return nil, err
	}
	log.Infof("saved uploaded file %v (%v bytes written)", f.Name(), numWritten)

	if err := f.Close(); err != nil {
		return nil, err
	}
	return f, nil
}
